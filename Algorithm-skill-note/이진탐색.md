## 이진 탐색
> 결정 알고리즘으로 사용, `답이 특정 범위` 내에 정해져 있는 특징
````
1. 몇 부터 몇 까지 답이 정해져 있다.
2. 중앙값이 답으로써 유효한지 안 유효한지? 
3. 답이 된다면 범위를 좁혀서 더 좋은 답을 도출한다. 
````
#### ex) 유형>이분/그리디/2.랜선자르기<br> 
 K개의 랜선, N개의 자른 전선을 원함 `N개로 자를 수 있는 최대 전선의 길이는 몇인가?`
  
K = [802, 743, 457, 539]<br> 
해당 리스트에서 최대값은 802이다.
> 해당 문제의 `답은 0~802 사이`일 것이다.

* 이제 0과 802사이를 절반씩 갈라가면서 answer를 도출해내면 된다. 
````
start = 1
end = max_arr
answer = 0
while start <= end :
    mid = (start+end)//2
    if Count(mid) >= n : # 타겟보다 더 많이 나온다면? (나누는 인자를 크게한다)-> start=mid+1
        answer = mid
        start = mid+1
    else : # 타겟보다 더 적게 나온다면? 나누는 인자를 더 작게한다.
        end = mid-1
````

보통 재귀함수로 구현하지만, 직관적으로 풀기 위해서 당분간은 While문의 Start, End, Mid 변수를 활용하여 해결 할 것

## 실전 Tip 
#### 1. if Count() `>=,<=` target 결정 방법 
`정답영역이 포함 되도록 설정 할 것`
: 계속해서 반복문이 실행 될 수 있도록, `처음 답을 고려`하여 더 과하거나 부족한 영역으로 부등호를 설정한다. 

ex)<br>
4번. 마구간 정하기 
말을 3마리 배치(target) <br>
처음 거리 5 : 2마리 배치 가능(정답 영역X) But 4마리는 정답영역O
따라서, `if Count(mid)>=target`

3번. 뮤직비디오 
CD 3개에 녹화 (target)<br>
   따지고 보면 2개에 녹화해도 이득이므로 정답영역이 맞음
따라서, `if Count(mid)<=target`

#### 2. Count()함수의 입력값과 출력값의 비례/반비례 관계 확인 할 것
: if -else 조건문에서의 start=mid +1 혹은 end = mid -1의 위치를 판단하는 중요한 잣대



